\section{Введение}	

Задачи автоматизированного  реинжиниринга  программ выдвигают особые требования к генераторам синтаксических анализаторов.

Для устаревшего языка сложно (а зачастую и невозможно) задать однозначную контекстно-свободную грамматику. Необходимо существенно преобразовать его спецификацию, которая приводится в документации, чтобы получить такую грамматику. Но после этого она перестает быть сопровождаемой~\cite{CurrentParsTechn}. Поэтому устаревший язык обычно задается с помощью неоднозначной контекстно-свободной грамматики.

При решении задач реинжиниринга часто требуются преобразования уже существующей грамматики. При этом,зачастую, изменение одного правила приводит к появлению десятков конфликтов в грамматике~\cite{CurrentParsTechn}, которые необходимо разрешать вручную, что требует большого количества времени.

Как вариант решения этих задач предлагается использовать GLR грамматики и соответствующие инструменты построения анализаторов~\cite{CurrentParsTechn}. Действительно, GLR-алгоритм разрешает неоднозначности в грамматике на уровне концепции. Это избавляет он необходимости ручного устранения конфликтов, что существенно сокращает время и упрощает разработку грамматики. Важным плюсом является ещё и то, что код становится компактнее и сопровождаемее.
      
Главным достоинством GLR-алгоритма является обработка неоднозначных грамматик. Анализатор, построенный по неоднозначной  грамматике с помощью данного алгоритма, в общем случае, в результате разбора строит не единственное дерево, а несколько деревьев - лес, содержащий все возможные варианты вывода. Дальнейшая работа с полученным лесом организуется исходя из требований и  особенностей решаемой задачи.
%который можно сократить, используя специальные фильтры, а можно ,при задании в одной спецификации нескольких диалектов, вернуть весь лес для дальнейшего выбора нужного дерева/диалекта.   

Работу GLR-алгоритма  можно рассматривать как параллельное исполнение набора LR-анализаторов. При этом данный набор дополняется процедурой управления стеками, оптимизирующей представление стеков путем их «склеивания» и «расклеивания», что позволяет хранить и строить параллельные выводы в рамках одного LR-анализатора, лишь в моменты их различия добавляя параллельный анализатор.

Оказалось, что весьма наглядно такой алгоритм может быть представлен в виде двух взаимно-рекурсивных функций (рекурсивно-восходящий алгоритм, recursive ascent). При этом расклеивание стека получается естественным образом как ветвление в одной из функций, а обратное склеивание может быть реализовано как кэширование результата функции.

Стоит отметить, что по производительности такой анализатор, являясь некоторой "надстройкой" \ над LR-анализатором, незначительно ему уступает. На сегодняшний день в соотношении производительность/класс разбираемых языков GLR-алгоритм выглядит наиболее предпочтительно.

Удобным способом формального определения грамматики, элементов и атрибутов языка программирования является расширенная нормальная форма Бэкуса-Наура. Поэтому инструмент должен работать с расширенными контекстно-свободными грамматиками. 

При работе с инструментом пользователь ожидает получить результат описанный в терминах заданной им грамматики. Это выдвигает дополнительные требования к алгоритму. В случае, если входная грамматика была каким-либо образом преобразована, например с целью раскрыть конструкции EBNF, то появляется необходимость в построении "обратного" \ преобразования. Это преобразование должно "перевести" \ результат обратно в термины входной грамматики. Такие преобразования  требуют дополнительных ресурсов и усложняют инструмент. Поэтому наиболее предпочтительными является алгоритмы, позволяющие обойтись без дополнительных преобразований грамматики.