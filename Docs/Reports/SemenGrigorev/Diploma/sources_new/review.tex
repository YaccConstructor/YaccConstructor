\section{Обзор}

%\subsection{Общие требования к языку спецификации трансляции}

%Краткие требования к языку. YARD достаточно полно удовлентворяет этим требованиям, поэтоиу выбрали его.

\subsection{Алгоритмы анализа и их реализации}

Предпочтительным алгоритмом анализа является алгоритм для работы с произвольными контекстно-свободными грамматиками. Поэтому были рассмотрены инструменты, обладающие соответствующими возможностями. Важным моментом является внутренняя реализация, так как существуют несколько альтернативных подходов к работе с произвольными контекстно-свободными грамматиками: алгоритм Томиты (GLR-алгоритм), алгоритм Эрли (Early), рекурсивно-восходящий алгоритм. 
       
В настоящее время существуют следующие инструменты основанные на GLR-алгоритме.
\begin{itemize}
	\item
	 ASF+SDF~\cite{ASF+SDF} (Algebraic Specification Formalism + Syntax Definition Formalism) -- генератор с широкими возможностями, но достаточно сложным входным языком. Является SGLR-инструментом (Scannerless, Generalized-LR).
	
	\item
	 Bison~\cite{Bison} - развитие инструмента YACC. Все грамматики, созданные 	для оригинального YACC, будут работать и в Bison. Является одним 	из самых популярных и совершенных "потомков" \ YACC. При включении 	соответствующей опции использует GLR-алгоритм (по умолчанию LALR).
	
	\item
	Elkhound~\cite{Elkhound} - позиционируется как быстрый и удобный GLR-инструмент, созданный в университете Беркли (США), тем не менее обладает достаточно 	"бедным" \ входным языком (например, он не поддерживает конструкций 	расширенной формы Бэкуса-Наура).
	
\end{itemize}

В работе~\cite{CCReview} проведён подробный анализ этих инструментов.

Необходимо отметить, что многие рассмотренные инструменты либо обладают сравнительно бедным входным языком, что усложняет разработку, либо проводят сильные преобразования грамматики во время работы, что может серьёзно усложнить отладку.

Так же был рассмотрен инструмент Jade.
Jade это генератор рекурсивно-восходящих LALR(1) парсеров с целевым языком С. Его подробное описание приводится в статье~\cite{Jade}. При реализации данного инструмента появилась проблема объёма кода целевого парсера. Так как при построении детерминированного парсера необходимо генерировать процедуры для каждого состояния, то объём кода быстро растёт, с ростом количества правил в грамматике. Так для языка Java объём кода составляет примерно 4 мегабайта~\cite{Jade}. В Jade  эта проблема решается путём создания глобальной структуры(массива состояний), где хранится информация, позволяющая переиспользовать процедуры~\cite{Jade}.

\subsection{Атрибутные грамматики. Подходы к вычислению атрибутов}

При работе с произвольными грамматиками выдвигаются особые требования к алгоритму вычисления атрибутов. Это связано с тем, что в качестве атрибута пользователь может указать действие, обладающее побочным эффектом (например, печать на экран). При наличии таких атрибутов нельзя проводить вычисления непосредственно в процессе анализа, так как в момент разбора не возможно определить, завершиться ли текущая ветвь удачно. В ситуациях, когда при непосредственном вычислении ветвь завершилась неудачно, могут быть совершены лишние действия (например, лишняя печать на экран).

Были рассмотрены два подхода к решению этой проблемы: 
\begin{itemize}

	\item {\bfseries Отложенные вычисления} (continuation passing style, CPS). Непосредственно во время разбора атрибуты не вычисляются. Вычисления откладываются. Строится функция, которая вычисляется только один раз, после удачного завершения разбора.
	
	\item {\bfseries Интерпретация леса вывода} - построение леса вывода и последующее вычисление атрибутов над ним. Первым шагом строится лес вывода, который содержит только деревья, соответствующие успешным вариантам разбора. Следующим шагом над полученным лесом производятся вычисления, соответствующие заданным атрибутам.
	
\end{itemize}

Оба этих подхода гарантируют, что будут выполнены действия, соответствующие только успешным вариантам разбора. Однако второй подход является более удобным для конечного пользователя, так как позволяет явно получить дерево вывода, что упрощает отладку.



%Вторым важным требованием к алгоритму вычисления атрибутов является минимизация, а в идеале - отсутствие, преобразований входной грамматики/дерева вывода.

%Так как инструмент должен работать с EBNF грамматиками без их преобразования, то при вычислении над деревом вывода возникли сложности, связанные с тем, что для конкретного узла сыновья одного уровня образуют строку языка, заданного регулярным выражением в правой части правила, соответствующего этому узлу. Для вычислений нужна более подробная информация о выводе данной строки. Для решения этой проблемы возможны несколько вариантов: 
%\begin{itemize}
 %    \item С преобразованием входной грамматики. Добавление правил в грамматику, соответствующих атрибутам в исходной грамматике.
 %    \item Без преобразования входной грамматики. Добавление меток к узлам дерева вывода, с помощью которых можно восстановить дерево вывода этой строки.
%\end{itemize}

%Был выбран второй вариант, так как одним из требований к инструменту было минимальное преобразование входной грамматики.

%%Ниже приведён рисунок, кратко поясняющий основную идею выбранного алгоритма.

%%\includepdf{sample_for_label_general_ru.pdf}

%Результат обзора - в качестве алгоритма анализа выбран рекурсивно-восходящий алгоритм, для вычисления атрибутов выбран второй подход(интерпретация дерева вывода).